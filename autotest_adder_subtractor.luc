module auto_test (
  input clk,  // clock
  input rst,  // reset
  input trigger_start,
  input trigger_error, // force error -> io_dip can trigger?, push up to invert that specific bit
  output out[16],
  output seg_out[4][4]
) {

// STEP 1: Declare my components
adder_subtractor_unit adder_subtractor16 
// alu alu16(.clk(clk), .rst(rst)); //can i remove this line to test this unit? 
counter slow_clock (.clk(clk), .rst(rst), #SIZE(1), #DIV(27));
edge_detector slow_edge (.clk(clk), #RISE(1), #FALL(0));

// STEP 2: Setup test values register and fsm
dff test_values[4](#INIT(0), .clk(clk), .rst(rst));  // Number of bits required depends on number of test cases
fsm test_states (.clk(clk), .rst(rst)) = {IDLE, START, PASS, ERROR}; 

always {

  // STEP 3: Setup default values for inputs  
  adder_subtractor16.a = h0000;
  adder_subtractor16.b = h0000;
  adder_subtractor16.alufn_op = b000000;
  out = hFFFF;
  seg_out = {4d0, 4d0, 4d0, 4d10};
  slow_edge.in = slow_clock.value;
  
  // STEP 4: Start FSM Code
  case (test_states.q) {
    test_states.IDLE:
      if (trigger_start == b1) {
        test_values.d = 0;
        test_states.d = test_states.START;
      }
    
    // STEP 5: Declare all test cases under state = start
    test_states.START:
      case(test_values.q) {
      
        // Test 1 - 0+0
        b0:
          adder_subtractor16.alufn_op = b000000;
          adder_subtractor16.a = h0000;
          adder_subtractor16.b = h0000;
          out = adder_subtractor16.out;
          seg_out = {4d0, 4d0, 4d0, 4d1};
          
          // Answer check
          if (adder_subtractor16.out != h0000) {
            test_states.d = test_states.ERROR;
          }
          else if (slow_edge.out) {
            test_values.d = test_values.q+1;
          }
          
        // Test 2 - 0 + 1 = 1
        b1: 
          adder_subtractor16.alufn_op = b000000;
          adder_subtractor16.a = h0000;
          adder_subtractor16.b = h0001;
          out = adder_subtractor16.out;
          seg_out = {4d0, 4d0, 4d0, 4d2};
          
          // Answer check
          if (adder_subtractor16.out != h0001) {
            test_states.d = test_states.ERROR;
          }
          else if (slow_edge.out) {
            test_values.d = test_values.q+1;
          }
          
        // Test 3 - 1+0 = 1 
        b10:
          adder_subtractor16.alufn_op = b000000;
          adder_subtractor16.a = h0001;
          adder_subtractor16.b = h0000;
          out = adder_subtractor16.out;
          seg_out = {4d0, 4d0, 4d0, 4d3};
          
          // Answer check
          if (adder_subtractor16.out != h0001) {
            test_states.d = test_states.ERROR;
          }
          else if (slow_edge.out) {
            test_values.d = test_values.q+1;
          }
          
        // Test 4 - 1+1
        b11:
          adder_subtractor16.alufn_op = b000000;
          adder_subtractor16.a = h0001;
          adder_subtractor16.b = h0001;
          out = adder_subtractor16.out;
          seg_out = {4d0, 4d0, 4d0, 4d4};
          
          // Answer check
          if (adder_subtractor16.out != 16h0002) {
            test_states.d = test_states.ERROR;
          }
          else if (slow_edge.out) {
            test_values.d = test_values.q+1;
          }
          
        // Test 5 - 0 + -1
        b100:
          adder_subtractor16.alufn_op = b000000;
          adder_subtractor16.a = h0000;
          adder_subtractor16.b = hFFFF;
          out = adder_subtractor16.out;
          seg_out = {4d0, 4d0, 4d0, 4d5};
          
          // Answer check
          if (adder_subtractor16.out != hFFFF) {
            test_states.d = test_states.ERROR;
          }
          else if (slow_edge.out) {
            test_values.d = test_values.q+1;
          }
          
        // Test 6 - h7FFF + h0001 = positive overflow 
        b101:
          adder_subtractor16.alufn_op = b000000;
          adder_subtractor16.a = h7FFF;
          adder_subtractor16.b = h0001;
          out = adder_subtractor16.out;
          v = adder_subtractor16.v;
          seg_out = {4d0, 4d0, 4d0, 4d6};
          
          // Answer check
          if (v != 1) {
            test_states.d = test_states.ERROR;
          }
          else if (slow_edge.out) {
            test_values.d = test_values.q+1;
          }
          
        // Test 7 - h8000 + h8000 -> negative overflow 
        b110:
          //current = b01;
          adder_subtractor16.alufn_op = b000000;
          adder_subtractor16.a = h8000;
          adder_subtractor16.b = h8000;
          out = adder_subtractor16.out;
          v = adder_subtractor16.v;
          seg_out = {4d0, 4d0, 4d0, 4d7};
          
          // Answer check
          if (v!= 1) {
            test_states.d = test_states.ERROR;
          }
          else if (slow_edge.out) {
            test_values.d = test_values.q+1;
          }  
          
        // Test 8 - Subtract: 1-1 = 0
        b111:
          adder_subtractor16.alufn_op = b000001;
          adder_subtractor16.a = h0001;
          adder_subtractor16.b = h0001;
          out = adder_subtractor16.out;
          seg_out = {4d0, 4d0, 4d0, 4d8};
          
          // Answer check
          if (adder_subtractor16.out != h0000) {
            test_states.d = test_states.ERROR;
          }
          else if (slow_edge.out) {
            test_values.d = test_values.q+1;
          }  
          
        // Test 9 - Subtract h8000 -h7000 -> negative overflow 
        b1000:
          adder_subtractor16.alufn_op = b000001;
          adder_subtractor16.a = h8000;
          adder_subtractor16.b = h7000;
          out = adder_subtractor16.out;
          v = adder_subtractor16.v;
          seg_out = {4d0, 4d0, 4d0, 4d9};
          
          // Answer check
          if (v!=1) {
            test_states.d = test_states.ERROR;
          }
          else if (slow_edge.out) {
            test_values.d = test_values.q+1;
          }  
          
        
         
        b1001:
          test_states.d = test_states.PASS;
      }
      
    test_states.PASS:
      out = 16b0;
      seg_out = {4d14, 4d10, 4d13, 4d13};
    
    test_states.ERROR:
      //out = 16hEEEE;
      seg_out = {4d11, 4d15, 4d15, 4d0};
  }
}
}

// Adder / Subtractor Total test cases : 15? 

// Adder - +
// Test 1 : 0+0= 0 
// Test 2:  0+1 = 1
// Test 3:  1+0 = 1
// Test 4 : 1+1 = 2 
// Test 5:  0 + -1 = -1
// Test 6 : h7FFF + h0001 = positive overflow -> error msg ("OFLO" in 7-segment) -> manual test how to detect?
// Test 7: h8000 + h8000 = negative overflow -> error msg ("OFLO")
// Extra Test :  1 + -1 = 0 
// extra Test  : -1 + (-1) = -2 

// Subtractor - - 
// Test 8 : 1-1 =  0

// Test 9: h8000 -h7000 = negative overflow 
// Test 10 : 0 - h8000 = positive overflow 
// Test 11 : -1 - (-1) =0
// Test 12: 0 - (-1) = 1
// Test 13: (-1) - (1) = -2 

