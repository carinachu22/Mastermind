module regfile_manual_test (
    input clk,  // clock
    input rst,  // reset
    input dips[16], // dip switches
    input trigger_start,
    output out[16],
    output write_status[1],
    output seg_out[4][5]
  ) {
  
  // STEP 1: Declare my components
  //alu alu16 (.rst(rst));
  regfile regfile(.clk(clk), .rst(rst));
  
  // STEP 2: Setup values register (ONLY FOR TESTING!)
  // DFFS WONT APPEAR IN FINAL FSM SINCE VALUES ARE LOCAL TO man_states
  dff ra[4](#INIT(0), .clk(clk), .rst(rst));
  dff rb[4](#INIT(0), .clk(clk), .rst(rst));
  dff rc[4](#INIT(0), .clk(clk), .rst(rst));
  dff w_signal[1](#INIT(0), .clk(clk), .rst(rst));
  dff w_data[16](#INIT(0), .clk(clk), .rst(rst));
  
  fsm man_states (.clk(clk), .rst(rst)) = {IDLE, CHECKDEFAULT, WAITRA, WAITRB, WAITRC, WAITWE, WAITDATA, CHECKREG}; 
  
  always {
    regfile.ra = 4b0;
    regfile.rb = 4b0;
    regfile.rc = 4b0;
    regfile.we = b0;
    regfile.wr_data = b0;
    out = 16h0000;
    seg_out = {5d0, 5d0, 5d14, 5d10};
    write_status = b0;
    
    case (man_states.q) {
      man_states.IDLE:
        
        // When looping back from the last state (CHECKALU), reset everything
        regfile.ra = 4b0;
        regfile.rb = 4b0;
        regfile.rc = 4b0;
        regfile.we = b0;
        regfile.wr_data = b0;
        out = 16h0000;
        seg_out = {5d0, 5d0, 5d0, 5d14};
        write_status = b0;
        
        if (trigger_start == b1) {
          man_states.d = man_states.WAITRA;
        }
        
      man_states.WAITRA:
        out = dips;
        seg_out = {5d0, 5d0, 5d0, 5d10};
        if (trigger_start == b1) {
          ra.d = dips[3:0];
          man_states.d = man_states.WAITRB;
        }
       
      man_states.WAITRB:
        out = dips;
        seg_out = {5d0, 5d0, 5d0, 5d11};
        if (trigger_start == b1) {
          rb.d = dips[3:0];
          man_states.d = man_states.WAITRC;
        }
        
      man_states.WAITRC:
        out = dips;
        seg_out = {5d0, 5d0, 5d0, 5d13};
        if (trigger_start == b1) {
          rc.d = dips[3:0];
          man_states.d = man_states.WAITWE;
        }
        
      man_states.WAITWE:
        out = dips;
        seg_out = {5d0, 5d0, 5d0, 5d14};
        if (trigger_start == b1) {
          w_signal.d = dips[0];
          man_states.d = man_states.WAITDATA;
        }
        
      man_states.WAITDATA:
        out = dips;
        seg_out = {5d0, 5d0, 5d0, 5d15};
        if (trigger_start == b1) {
          w_data.d = dips;
          man_states.d = man_states.CHECKREG;
        }
        
      man_states.CHECKREG:
        seg_out = {5d17, 5d1, 5d18, 5d14};
        
        regfile.ra = ra.q;
        regfile.rb = rb.q;
        regfile.rc = rc.q;
        regfile.we = w_signal.q;
        regfile.wr_data = w_data.q;
        
        // TESTING
        case(dips){
          // READ REGISTER A ADDRESS
          16h0:
            out = regfile.ra_addr;
          // READ REGISTER A DATA
          16h1:
            out = regfile.ra_data;
          // READ REGISTER B ADDRESS
          16h2:
            out = regfile.rb_addr;
          // READ REGISTER B DATA
          16h3:
            out = regfile.rb_data;
          // CHECK WRITE DATA <- debugging only
          // to compare to written register (either A or B)
          // Remove in final project
          16h4:
            out = regfile.data;
        }
        
        if (trigger_start == b1) {
          man_states.d = man_states.IDLE;
        }
  }
}