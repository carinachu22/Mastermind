module led2 (
    input clk,  // clock
    input rst,  // reset
    input dips[16], // dip switches
    input trigger_start, //This is a debug button to move from states to states -> most left button
    input colour_button, //Colour_button -> C2
    input confirm_button, //confirm_button -> C3
    output out[16],
    output seg_out[4][5],
    // add output from ledout[4][1]
    output outled[4]
  ) {
  
  var index;
  
  alu alu16 (.rst(rst));
  regfile regfile(.clk(clk), .rst(rst));
  sel_mux sel_mux;
  
  // INSTANTIATE LEDOUT IN FSM HERE
  led_out led_out[4](.clk(clk), .rst(rst));
  
  counter slow_clock (.clk(clk), .rst(rst), #SIZE(1), #DIV(26));
  edge_detector slow_edge (.clk(clk), #RISE(1), #FALL(0));
  dff current_led[16](.clk(clk), .rst(rst));
  dff current_strip[4](.clk(clk), .rst(rst));
  fsm phase(.clk(clk), .rst(rst)) = {IDLE,UPDATEHINTLED,
    POSITION,
    BRANCHCOLOURINDEX,
    INCREASECOLOURINDEX,
    UPDATECOLOURINDEX,
    BACKTOFIRSTCOLOURINDEX,
    UPDATECOLOURPOS0,
    ADDTOGUESSINDEX,
    UPDATEGUESSINDEX,
    SHIFTLEFTGUESSINDEX,
    UPDATESHIFTEDGUESSINDEX,
    BRANCHCHECKPOSITIONINDEX,
    INCREASEPOSITIONINDEX,
    UPDATEPOSITIONINDEX,
    FINISH,
    
    ANDLEDSTRIP,
    SHIFTCOLOUR,
    UPDATELEDCOLOUR,
    UPDATEPHASETWOLED,
    SHIFTXORHELPER,
    UPDATEXORHELPER,
    XOR,
    BRANCHSHIFTCOLOURPOSITION,
    SHIFTCOLOUR0,
    SHIFTCOLOUR1,
    SHIFTCOLOUR2,
    SHIFTCOLOUR3
    };

  always {
    // INITIALIZE VALUES
    regfile.ra = 4b0;
    regfile.rb = 4b0;
    regfile.rc = 4b0;
    regfile.we = b0;
    regfile.wr_data = b0;
    alu16.alufn_signal = 6b0;
    sel_mux.asel_signal = 2b0;
    sel_mux.bsel_signal = 3b0;
    sel_mux.wdsel_signal = 2b0;
    current_strip.d = 4b1000;
    
    // CONNECTIONS
    sel_mux.ra_data = regfile.ra_data;
    sel_mux.rb_data = regfile.rb_data;
    alu16.a = sel_mux.asel_out;
    alu16.b = sel_mux.bsel_out;
    sel_mux.alu_data = alu16.out;
    regfile.wr_data = sel_mux.wdsel_out;
    
    out = 16b0;
    seg_out =  {5b0, 5b0, 5b0, 5b0};
    
    slow_edge.in = slow_clock.value;
    
    led_out.update = 4x{0};
    led_out.encode = 4x{{16b0}};
    
    // ALWAYS CONNECT OUTPUT OF LEDOUT
    outled = led_out.led;
    case (phase.q){
    phase.IDLE:
        seg_out = {5d1,5d15, 5d16, 5d13};
        if(trigger_start){
          phase.d = phase.POSITION;
        }
    phase.POSITION:
        seg_out = {5d0,5d21, 5d14, 5d16};
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4hE; // READ REG A - ERROR REG
        regfile.rb = 4h3; // READ REG B - CURRENT GUESS COUNT
        
        // SELECTOR MUX
        sel_mux.asel_signal = 2b0; // ACCESS RA
        sel_mux.bsel_signal = 3b0; // ACCESS RB
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.alufn_signal = 6b11010; // "A" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4h0; // WRITE REG C - --
        regfile.we = b0; // WRITE DISABLED
        
        // UPDATE LED
        led_out.encode = 4x{{sel_mux.asel_out}};
        
        out = sel_mux.asel_out;
        
        for (index = 0; index<4; index++) {
          led_out.update[index] = sel_mux.bsel_out[index]; // unless the correct signal (in this case button) is pressed, data will not update
        }
        
        // NOTE make this transition into BRANCHGAMEMODE AND transition using clock (will disappear hints in next state)
        if (trigger_start){
          phase.d = phase.BRANCHCOLOURINDEX;
        } 
    
      
      phase.BRANCHCOLOURINDEX: // 7seg: "0BCI"
        seg_out={5d0, 5d11, 5d12,5d1};
        
        // Purpose: Branch - If colour index ==8, go back to 2. Else increase colour index
        // I need to check this
        
        regfile.ra = 4h2;
        //regfile.rb = 4h0; // we dont use this
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b111; // ACCESS HARDCODE VALUE 7
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b110101; // CMPLT OPERATION - change to 7!!
        
        // If it is <8, i will go to state INCREASECOLOURINDEX
        // TODO need to change this to slow edge out
        if (sel_mux.wdsel_out && trigger_start){  // NOTE : why is it confirm_button?
          phase.d = phase.INCREASECOLOURINDEX;
        }
        //NOTE : why is it confirm_button?
        else if (trigger_start){ // Else if its ==8, I will go to state BACKTOFIRSTCOLOURINDEX
          phase.d = phase.BACKTOFIRSTCOLOURINDEX;
        }
      
      phase.INCREASECOLOURINDEX:
        
        seg_out={5d0, 5d1, 5d12,5d1}; //7SEG: 01C1
        // Purpose: Read current colour index, +1 to it, and write back to the colour index reg file
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4h2; // Refile rb = -- regfile rc = --
        regfile.rb = 4h0; // we don't use this
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b010; // output is 1 from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b000000; // ADD OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4hF; // WRITE REG C - back to colour register // test write to temp register
        regfile.we = b1; // WRITE ENABLED
        
        if (trigger_start){ // NOTE: why confirm_button?
          phase.d = phase.UPDATECOLOURINDEX;
        }
      
      
      phase.UPDATECOLOURINDEX:
        
        seg_out={5d0, 5d21, 5d12,5d1}; //7SEG: 0UC1
        // Purpose: Update colour index register
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4hF; // Refile rb = -- regfile rc = --
        regfile.rb = 4h0; // we don't use this
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b0; // output is 1 from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b11010; // "A" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4h2; // WRITE REG C - back to colour register // test write to temp register
        regfile.we = b1; // WRITE ENABLED
        
        out = sel_mux.asel_out;
        
        if (trigger_start){
          //phase.d = phase.SHIFTLEFTGUESSINDEX;
           phase.d = phase.XOR;
        }
        //else if (colour_button){
          //phase.d = phase.BRANCHCOLOURINDEX;
        //}
      phase.XOR: 
          seg_out={5d0, 5d20, 5d0,5d20}; //7SEG: 0ROR
        // Purpose: Xor the xor helper and 1111
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 5h10; // REG A XOR HELPER
        regfile.rb = 4h0; // REG B 
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b1110; // output is 4hFFFF from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b010110; // "XOR" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4hF; // WRITE REG C to temp register
        regfile.we = b1; // WRITE ENABLED
        
        out = sel_mux.wdsel_out;
        
        if (trigger_start){
          //phase.d = phase.SHIFTLEFTGUESSINDEX;
           phase.d = phase.ANDLEDSTRIP;
        }
      phase.ANDLEDSTRIP:
        seg_out={5d0, 5d10, 5d16,5d18}; //7SEG: 0ALS
        // Purpose: To have the guess register but in the position that we are in, they are 0s 
        // For example 1111 0000 1100 1100 (for position 1) 
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4h7; // REG A initial all green
        regfile.rb = 4hF; // REG B TEMP REGISTER AND helper
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b0; // output is 1 from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b011000; // "AND" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 5h11; // WRITE REG C to colour helper
        regfile.we = b1; // WRITE ENABLED
        
        out = sel_mux.wdsel_out;
        
        if (trigger_start){
           phase.d = phase.BRANCHSHIFTCOLOURPOSITION;
        }
      phase.BRANCHSHIFTCOLOURPOSITION: 
          //Purpose: I read my current position, to go to differnt branches with different shift contatnts 
        seg_out={5d11, 5d18, 5d12,5d19}; //7SEG: BSCP
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4h1; // REG A POSITION REGISTER
        regfile.rb = 4h0; // 
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b0; // output is 12 from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b011010; // "A" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4hF; // WRITE REG C to temp register
        regfile.we = b0; // WRITE ENABLED
        
        out = sel_mux.wdsel_out;
        
        if (trigger_start&&sel_mux.wdsel_out==0){
          
           phase.d = phase.SHIFTCOLOUR0;
        }
        
        else if (trigger_start&&sel_mux.wdsel_out==1){
          
           phase.d = phase.SHIFTCOLOUR1;
        }
        
        else if (trigger_start&&sel_mux.wdsel_out==2){
          
           phase.d = phase.SHIFTCOLOUR2;
        }
        
        else if (trigger_start&&sel_mux.wdsel_out==3){
          
           phase.d = phase.SHIFTCOLOUR3;
        }
          
      phase.SHIFTCOLOUR0:
        //Purpose: I shift my colour register to the correct position to add 
        seg_out={5d18, 5d14, 5d16,5d0}; //7SEG: SHL0
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4h2; // REG A colour register
        regfile.rb = 4h0; // 
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b1100; // output is 12 from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b100000; // "SHL" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4hF; // WRITE REG C to temp register
        regfile.we = b1; // WRITE ENABLED
        
        out = sel_mux.wdsel_out;
        
        if (trigger_start){
          //phase.d = phase.SHIFTLEFTGUESSINDEX;
           phase.d = phase.UPDATELEDCOLOUR;
        }
       phase.SHIFTCOLOUR1:
        //Purpose: I shift my colour register to the correct position to add 
        seg_out={5d18, 5d14, 5d16,5d1}; //7SEG: SHL1
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4h2; // REG A colour register
        regfile.rb = 4h0; // 
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b1000; // output is 8 from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b100000; // "SHL" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4hF; // WRITE REG C to temp register
        regfile.we = b1; // WRITE ENABLED
        
        out = sel_mux.wdsel_out;
        
        if (trigger_start){
          //phase.d = phase.SHIFTLEFTGUESSINDEX;
           phase.d = phase.UPDATELEDCOLOUR;
        } 
        
      phase.SHIFTCOLOUR2:
        //Purpose: I shift my colour register to the correct position to add 
        seg_out={5d18, 5d14, 5d16,5d2}; //7SEG: SHL2
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4h2; // REG A colour register
        regfile.rb = 4h0; // 
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b100; // output is 4 from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b100000; // "SHL" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4hF; // WRITE REG C to temp register
        regfile.we = b1; // WRITE ENABLED
        
        out = sel_mux.wdsel_out;
        
        if (trigger_start){
          //phase.d = phase.SHIFTLEFTGUESSINDEX;
           phase.d = phase.UPDATELEDCOLOUR;
        }  
        
      phase.SHIFTCOLOUR3:
        //Purpose: I shift my colour register to the correct position to add 
        seg_out={5d18, 5d14, 5d16,5d3}; //7SEG: SHL3
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4h2; // REG A colour register
        regfile.rb = 4h0; // 
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b0; // output is 4 from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b011010; // "SHL" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4hF; // WRITE REG C to temp register
        regfile.we = b1; // WRITE ENABLED
        
        out = sel_mux.wdsel_out;
        
        if (trigger_start){
          //phase.d = phase.SHIFTLEFTGUESSINDEX;
           phase.d = phase.UPDATELEDCOLOUR;
        }    
      
      phase.UPDATELEDCOLOUR:
        
        seg_out = {5d21, 5d16,5d19,5d0};
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4hF; // READ REG A - TEMP REG w colour in correct position
        regfile.rb = 5h11; // READ REG B - COLOUR HELPER
        
        // SELECTOR MUX
        sel_mux.asel_signal = 2b0; // ACCESS RA
        sel_mux.bsel_signal = 3b0; // ACCESS RB
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.alufn_signal = 6b000000; // "ADD" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4h7; // WRITE REG C - GUESS REGISTER
        regfile.we = b1; // WRITE DISABLED
      
        // NOTE make this transition into BRANCHGAMEMODE AND transition using clock (will disappear hints in next state)
        if (trigger_start){
          phase.d = phase.UPDATEPHASETWOLED;
           
        }
        
      
    
      phase.UPDATEPHASETWOLED:
         seg_out = {5d0, 5d21,5d12,5d16};
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4h7; // READ REG A - GUESS REGISTER
        regfile.rb = 4h3; // READ REG B - POSITION REGISTER
        
        // SELECTOR MUX
        sel_mux.asel_signal = 2b0; // ACCESS RA
        sel_mux.bsel_signal = 3b0; // ACCESS RB
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.alufn_signal = 6b000000; // "ADD" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4h0; // WRITE REG C - GUESS REGISTER
        regfile.we = b0; // WRITE DISABLED
      
          
        // UPDATE LED
        led_out.encode = 4x{{sel_mux.asel_out}};
        
        out = sel_mux.asel_out;
        
        for (index = 0; index<4; index++) {
          led_out.update[index] = sel_mux.bsel_out[index]; // unless the correct signal (in this case button) is pressed, data will not update
        }
        // NOTE make this transition into BRANCHGAMEMODE AND transition using clock (will disappear hints in next state)
        if (confirm_button){
          phase.d = phase.BRANCHCHECKPOSITIONINDEX;
           
        }
        else if (colour_button){
          phase.d = phase.BRANCHCOLOURINDEX;
        }
       
          
      phase.BACKTOFIRSTCOLOURINDEX:
        
        seg_out={5d11, 5d17, 5d12,5d1}; // 7SEG: BFCI
        
        // Purpose: I want to 8-6
        // TODO we can probably delete this state, since by default 4hF = 0
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4h0; // Refile rb = -- regfile rc = --
        regfile.rb = 4h0; // we don't use this
        
        
        // SELECTOR MUX
        sel_mux.asel_signal=  b11; // output is 2 from asel
        sel_mux.bsel_signal= b0;
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b011010; // "A" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4hF; // Write to temp register
        regfile.we = b1; // WRITE ENABLED
        
        
        if (trigger_start){ // NOTE: why confirm_button ?
          phase.d = phase.UPDATECOLOURINDEX;
        }
      
    
      
      phase.BRANCHCHECKPOSITIONINDEX:
        seg_out={5d11, 5d12, 5d19,5d1}; // 7SEG: BCPI
        // Purpose: Read current colour index, -5 to it, and write back to the colour index reg file
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4h1; // position index
        regfile.rb = 4h0; // we don't use this
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b011; // output is 3 from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b110101; // CMPLT OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4h0; // No writing
        regfile.we = b0; // WRITE DISABLED
        
        // If position index < 3, go to state to increase position index
        if (sel_mux.wdsel_out && trigger_start){ // NOTE: why use confirm_button?
          phase.d =phase.INCREASEPOSITIONINDEX;
        }
        
        // Else if position index is ==3, go to phase 3
        else if(trigger_start){ // NOTE: why use confirm_button?
          phase.d = phase.FINISH;
        }
      
      
      phase.INCREASEPOSITIONINDEX:
        seg_out={5d0, 5d1, 5d19,5d1}; // 7SEG: BCPI
        // Purpose: Read current colour index, -5 to it, and write back to the colour index reg file
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4h1; // position index
        regfile.rb = 4h0; // we don't use this
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b010; // output is 1 from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b000000; // ADD OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4hF; // Write to temp register first
        regfile.we = b1; // WRITE ENABLED
        
        // Go to position state to wait for colour button press
        if (trigger_start){ // NOTE: why use confirm_button?
          phase.d = phase.UPDATEPOSITIONINDEX;
        }
      
      
      phase.UPDATEPOSITIONINDEX:
        
        seg_out={5d0, 5d21, 5d19,5d1}; //7SEG: 0UC1
        // Purpose: Update position index register
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4hF; // Refile rb = -- regfile rc = --
        regfile.rb = 4h0; // we don't use this
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b0; // output is 1 from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b11010; // "A" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4h1; // Update position index register
        regfile.we = b1; // WRITE ENABLED
        if (trigger_start){ // NOTE: why use confirm_button?
          phase.d = phase.SHIFTXORHELPER;
        }
        
      phase.SHIFTXORHELPER:
          //Purpose: I shift my xor helper by 4 to the right to go to the next position 
        seg_out={5d0, 5d18, 5d14,5d20}; //7SEG: 0ALS
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 5h10; // REG A XOR HELPER
        regfile.rb = 4h0; // 
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b100; // output is 4 from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b100001; // "SHL" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 4hF; // WRITE REG C to temp register
        regfile.we = b1; // WRITE ENABLED
        
        out = sel_mux.wdsel_out;
        
        if (trigger_start){
           phase.d = phase.UPDATEXORHELPER;
        }
      phase.UPDATEXORHELPER:   
        seg_out={5d21, 5d18, 5d14,5d20}; //7SEG: USHR
        
        // READ REGISTERS (ADDRESS AND SIGNAL ONLY)
        regfile.ra = 4hF; // REG A TEMP REG (XOR helper) 
        regfile.rb = 4h0; // 
        
        
        // SELECTOR MUX
        sel_mux.asel_signal= b0;
        sel_mux.bsel_signal= b100; // output is 4 from bsel
        sel_mux.wdsel_signal = 2b0; // ACCESS ALU OUTPUT OF RA AND RB
        
        // PASS THROUGH ALU
        alu16.a = sel_mux.asel_out;
        alu16.b = sel_mux.bsel_out;
        alu16.alufn_signal = 6b011010; // "A" OPERATION
        
        // WRITE REGISTERS (ACTUAL DATA)
        regfile.rc = 5h10; // WRITE REG C to XOR HELPER REG 
        regfile.we = b1; // WRITE ENABLED
        
        out = sel_mux.wdsel_out;
        
        if (trigger_start){
          //phase.d = phase.SHIFTLEFTGUESSINDEX;
           phase.d = phase.BACKTOFIRSTCOLOURINDEX;
        }
      
      phase.FINISH:
        seg_out={5d17, 5d1, 5d18,5d14};
        
  }
}
