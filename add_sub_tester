module add_sub_tester(
    input clk,  // clock
    input rst,  // reset
    input trigger_start, 
    output out,
    output seg_out[4][4]   
){
  
// STEP 1: Declare my components
add_sub_unit adder_subtractor16;
counter slow_clock (.clk(clk), .rst(rst), #SIZE(1), #DIV(27));
edge_detector slow_edge (.clk(clk), #RISE(1), #FALL(0));
autotest_rom_answers rom_answers;
  
// STEP 2: Setup test values register and fsm
dff test_values[4](#INIT(0), .clk(clk), .rst(rst));  // Number of bits required depends on number of test cases
fsm test_states (.clk(clk), .rst(rst)) = {IDLE, TESTING, ERROR, OVERFLOW, DEBUG, PASS}; 

always {

  // STEP 3: Setup default values for inputs  
  adder_subtractor16.a = h0000;
  adder_subtractor16.b = h0000;
  adder_subtractor16.alufn = b000000;
  rom_answers.address = 0;
  out = hFFFF;
  seg_out = {4d0, 4d0, 4d0, 4d10};
  slow_edge.in = slow_clock.value;
    
  //Initalise start to be 0 first
  if (trigger_start ==0){
    test_states.d = test_states.IDLE; }

    // STEP 4: Start FSM Code 
    case(test_states.q){
        test_states.IDLE:
            if (trigger_start == b1){
                test_values.d =0;
                test_states.d = test_states.TESTING;
            }

        // Declare TESTADDSUB cases 

        test_states.TESTING:
            case(test_values.q){
        
                // Test 1 - 
                b0:
                    rom_answers.address = test_values.q;
                    adder_subtractor16.a = rom_answers.answers[59:44];
                    adder_subtractor16.b = rom_answers.answers[43:28];
                    adder_subtractor16.alufn = rom_answers.answers[27:20]; //idk if 8 bits can be fed into 2 bits input -> if cannot, express in bits
                    seg_out = {4d0, 4d0, 4d0, 4d1};

                    // Correct answer
                    if (adder_subtractor16.out == rom_answers.answers[19:4] && adder_subtractor16.zvn==rom_answers.answers[3:0] && slow_edge.out) {
                        test_values.d = test_values.q+1;}
                    // Overflow 
                    else if (adder_subtractor16.zvn[1] == 1 && slow_edge.out) {
                        test_states.d = test_states.OVERFLOW;}
                    // Wrong output
                    else if (adder_subtractor16.out != rom_answers.answers[19:4] && slow_edge.out) {
                        test_states.d = test_states.ERROR;}
                    // Unknown errors 
                    else if (slow_edge.out){
                        test_states.d = test_states.DEBUG;}
                // Test 2 - 
                b1:
                    rom_answers.address = test_values.q;
                    adder_subtractor16.a = rom_answers.answers[59:44];
                    adder_subtractor16.b = rom_answers.answers[43:28];
                    adder_subtractor16.alufn = rom_answers.answers[27:20]; //idk if 8 bits can be fed into 2 bits input -> if cannot, express in bits
                    seg_out = {4d0, 4d0, 4d0, 4d1};

                    // Correct answer
                    if (adder_subtractor16.out == rom_answers.answers[19:4] && adder_subtractor16.zvn==rom_answers.answers[3:0] && slow_edge.out) {
                        test_values.d = test_values.q+1;}
                    // Overflow 
                    else if (adder_subtractor16.zvn[1] == 1 && slow_edge.out) {
                        test_states.d = test_states.OVERFLOW;}
                    // Wrong output
                    else if (adder_subtractor16.out != rom_answers.answers[19:4] && slow_edge.out) {
                        test_states.d = test_states.ERROR;}
                    // Unknown errors 
                    else if (slow_edge.out){
                        test_states.d = test_states.DEBUG;}

                // Test 3 - 
                b10:
                    rom_answers.address = test_values.q;
                    adder_subtractor16.a = rom_answers.answers[59:44];
                    adder_subtractor16.b = rom_answers.answers[43:28];
                    adder_subtractor16.alufn = rom_answers.answers[27:20]; //idk if 8 bits can be fed into 2 bits input -> if cannot, express in bits
                    seg_out = {4d0, 4d0, 4d0, 4d1};

                    // Correct answer
                    if (adder_subtractor16.out == rom_answers.answers[19:4] && adder_subtractor16.zvn==rom_answers.answers[3:0] && slow_edge.out) {
                        test_values.d = test_values.q+1;}
                    // Overflow 
                    else if (adder_subtractor16.zvn[1] == 1 && slow_edge.out) {
                        test_states.d = test_states.OVERFLOW;}
                    // Wrong output
                    else if (adder_subtractor16.out != rom_answers.answers[19:4] && slow_edge.out) {
                        test_states.d = test_states.ERROR;}
                    // Unknown errors 
                    else if (slow_edge.out){
                        test_states.d = test_states.DEBUG;}
                
                // Test 4 - 
                b11:
                    rom_answers.address = test_values.q;
                    adder_subtractor16.a = rom_answers.answers[59:44];
                    adder_subtractor16.b = rom_answers.answers[43:28];
                    adder_subtractor16.alufn = rom_answers.answers[27:20]; //idk if 8 bits can be fed into 2 bits input -> if cannot, express in bits
                    seg_out = {4d0, 4d0, 4d0, 4d1};

                    // Correct answer
                    if (adder_subtractor16.out == rom_answers.answers[19:4] && adder_subtractor16.zvn==rom_answers.answers[3:0] && slow_edge.out) {
                        test_values.d = test_values.q+1;}
                    // Overflow 
                    else if (adder_subtractor16.zvn[1] == 1 && slow_edge.out) {
                        test_states.d = test_states.OVERFLOW;}
                    // Wrong output
                    else if (adder_subtractor16.out != rom_answers.answers[19:4] && slow_edge.out) {
                        test_states.d = test_states.ERROR;}
                    // Unknown errors 
                    else if (slow_edge.out){
                        test_states.d = test_states.DEBUG;}
                
                // Test 5 - 
                b100:
                    rom_answers.address = test_values.q;
                    adder_subtractor16.a = rom_answers.answers[59:44];
                    adder_subtractor16.b = rom_answers.answers[43:28];
                    adder_subtractor16.alufn = rom_answers.answers[27:20]; //idk if 8 bits can be fed into 2 bits input -> if cannot, express in bits
                    seg_out = {4d0, 4d0, 4d0, 4d1};

                    // Correct answer
                    if (adder_subtractor16.out == rom_answers.answers[19:4] && adder_subtractor16.zvn==rom_answers.answers[3:0] && slow_edge.out) {
                        test_values.d = test_values.q+1;}
                    // Overflow 
                    else if (adder_subtractor16.zvn[1] == 1 && slow_edge.out) {
                        test_states.d = test_states.OVERFLOW;}
                    // Wrong output
                    else if (adder_subtractor16.out != rom_answers.answers[19:4] && slow_edge.out) {
                        test_states.d = test_states.ERROR;}
                    // Unknown errors 
                    else if (slow_edge.out){
                        test_states.d = test_states.DEBUG;}

                // Test 6 - 
                b101:
                    rom_answers.address = test_values.q;
                    adder_subtractor16.a = rom_answers.answers[59:44];
                    adder_subtractor16.b = rom_answers.answers[43:28];
                    adder_subtractor16.alufn = rom_answers.answers[27:20]; //idk if 8 bits can be fed into 2 bits input -> if cannot, express in bits
                    seg_out = {4d0, 4d0, 4d0, 4d1};

                    // Correct answer
                    if (adder_subtractor16.out == rom_answers.answers[19:4] && adder_subtractor16.zvn==rom_answers.answers[3:0] && slow_edge.out) {
                        test_values.d = test_values.q+1;}
                    // Overflow 
                    else if (adder_subtractor16.zvn[1] == 1 && slow_edge.out) {
                        test_states.d = test_states.OVERFLOW;}
                    // Wrong output
                    else if (adder_subtractor16.out != rom_answers.answers[19:4] && slow_edge.out) {
                        test_states.d = test_states.ERROR;}
                    // Unknown errors 
                    else if (slow_edge.out){
                        test_states.d = test_states.DEBUG;}

                // Test 7 - 
                b110:
                    rom_answers.address = test_values.q;
                    adder_subtractor16.a = rom_answers.answers[59:44];
                    adder_subtractor16.b = rom_answers.answers[43:28];
                    adder_subtractor16.alufn = rom_answers.answers[27:20]; //idk if 8 bits can be fed into 2 bits input -> if cannot, express in bits
                    seg_out = {4d0, 4d0, 4d0, 4d1};

                    // Correct answer
                    if (adder_subtractor16.out == rom_answers.answers[19:4] && adder_subtractor16.zvn==rom_answers.answers[3:0] && slow_edge.out) {
                        test_values.d = test_values.q+1;}
                    // Overflow 
                    else if (adder_subtractor16.zvn[1] == 1 && slow_edge.out) {
                        test_states.d = test_states.OVERFLOW;}
                    // Wrong output
                    else if (adder_subtractor16.out != rom_answers.answers[19:4] && slow_edge.out) {
                        test_states.d = test_states.ERROR;}
                    // Unknown errors 
                    else if (slow_edge.out){
                        test_states.d = test_states.DEBUG;}

                // Test 8 - 
                b111:
                    rom_answers.address = test_values.q;
                    adder_subtractor16.a = rom_answers.answers[59:44];
                    adder_subtractor16.b = rom_answers.answers[43:28];
                    adder_subtractor16.alufn = rom_answers.answers[27:20]; //idk if 8 bits can be fed into 2 bits input -> if cannot, express in bits
                    seg_out = {4d0, 4d0, 4d0, 4d1};

                    // Correct answer
                    if (adder_subtractor16.out == rom_answers.answers[19:4] && adder_subtractor16.zvn==rom_answers.answers[3:0] && slow_edge.out) {
                        test_values.d = test_values.q+1;}
                    // Overflow 
                    else if (adder_subtractor16.zvn[1] == 1 && slow_edge.out) {
                        test_states.d = test_states.OVERFLOW;}
                    // Wrong output
                    else if (adder_subtractor16.out != rom_answers.answers[19:4] && slow_edge.out) {
                        test_states.d = test_states.ERROR;}
                    // Unknown errors 
                    else if (slow_edge.out){
                        test_states.d = test_states.DEBUG;}
            }

            test_states.OVERFLOW:
                seg_out = {4d7, 4d7, 4d7, 4d7};
                if (slow_edge.out) {
                  test_states.d = test_states.TESTING;
              }

            test_states.ERROR:
                seg_out = {4d11, 4d15, 4d15, 4d0};
                 if (slow_edge.out) {
                test_states.d = test_states.TESTING;
                }

            test_states.DEBUG:
                seg_out = {4d8, 4d8, 4d8, 4d8};

            test_states.PASS:
                // i never inlude that out = 16b0. what is this for? 
                seg_out = {4d14, 4d10, 4d13, 4d13};

}